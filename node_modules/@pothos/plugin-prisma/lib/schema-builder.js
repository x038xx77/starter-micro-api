"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
require("./global-types");
const _core = /*#__PURE__*/ _interopRequireWildcard(require("@pothos/core"));
const _fieldBuilder = require("./field-builder");
const _modelLoader = require("./model-loader");
const _nodeRef = /*#__PURE__*/ _interopRequireDefault(require("./node-ref"));
const _cursors = require("./util/cursors");
const _datamodel = require("./util/datamodel");
const _description = require("./util/description");
const _getClient = require("./util/get-client");
const _mapQuery = require("./util/map-query");
const _relationMap = require("./util/relation-map");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const schemaBuilderProto = _core.default.prototype;
schemaBuilderProto.prismaObject = function prismaObject(type, { fields , findUnique , select , include , description , ...options }) {
    const ref = options.variant ? this.objectRef(options.variant) : (0, _datamodel.getRefFromModel)(type, this);
    var _variant, ref1;
    const name = (ref1 = (_variant = options.variant) !== null && _variant !== void 0 ? _variant : options.name) !== null && ref1 !== void 0 ? ref1 : type;
    const fieldMap = (0, _relationMap.getRelationMap)((0, _getClient.getDMMF)(this)).get(type);
    const idSelection = _modelLoader.ModelLoader.getDefaultIDSelection(ref, type, this);
    ref.name = name;
    this.objectType(ref, {
        ...options,
        description: (0, _description.getModelDescription)(type, this, description),
        extensions: {
            ...options.extensions,
            pothosPrismaInclude: include,
            pothosPrismaModel: type,
            pothosPrismaFieldMap: fieldMap,
            pothosPrismaSelect: select && {
                ...idSelection,
                ...select
            },
            pothosPrismaLoader: _modelLoader.ModelLoader.forRef(ref, type, findUnique, this)
        },
        name,
        fields: fields ? ()=>fields(new _fieldBuilder.PrismaObjectFieldBuilder(name, this, type, (0, _relationMap.getRelationMap)((0, _getClient.getDMMF)(this)).get(type))) : undefined
    });
    return ref;
};
schemaBuilderProto.prismaNode = function prismaNode(type, { id: { field , resolve: rawResolve , ...idOptions } , findUnique: rawFindUnique , name , variant , ...options }) {
    var _obj, ref;
    const fieldName = field;
    const interfaceRef = (ref = (_obj = this).nodeInterfaceRef) === null || ref === void 0 ? void 0 : ref.call(_obj);
    const resolve = rawResolve !== null && rawResolve !== void 0 ? rawResolve : (0, _cursors.getDefaultIDSerializer)(type, fieldName, this);
    const idParser = fieldName ? (0, _cursors.getDefaultIDParser)(type, fieldName, this) : undefined;
    var ref1;
    const typeName = (ref1 = variant !== null && variant !== void 0 ? variant : name) !== null && ref1 !== void 0 ? ref1 : type;
    const nodeRef = new _nodeRef.default(typeName);
    const findUnique = rawFindUnique ? (parent, context)=>rawFindUnique(resolve(parent, context), context) : _modelLoader.ModelLoader.getFindUniqueForField(nodeRef, type, fieldName, this);
    if (!interfaceRef) {
        throw new TypeError('builder.prismaNode requires @pothos/plugin-relay to be installed');
    }
    const extendedOptions = {
        ...options,
        variant,
        interfaces: [
            interfaceRef
        ],
        findUnique,
        loadWithoutCache: async (id, context, info)=>{
            const query = (0, _mapQuery.queryFromInfo)({
                context,
                info,
                typeName
            });
            const delegate = (0, _datamodel.getDelegateFromModel)((0, _getClient.getClient)(this, context), type);
            const record = await (delegate.findUniqueOrThrow ? delegate.findUniqueOrThrow({
                ...query,
                where: rawFindUnique ? rawFindUnique(id, context) : {
                    [fieldName]: idParser(id)
                }
            }) : delegate.findUnique({
                ...query,
                rejectOnNotFound: true,
                where: rawFindUnique ? rawFindUnique(id, context) : {
                    [fieldName]: idParser(id)
                }
            }));
            (0, _core.brandWithType)(record, typeName);
            return record;
        }
    };
    const ref2 = this.prismaObject(type, extendedOptions);
    if (options.interfaces) {
        this.configStore.addInterfaces(typeName, options.interfaces);
    }
    this.configStore.onTypeConfig(ref2, (nodeConfig)=>{
        var ref;
        var ref1;
        this.objectField(ref2, (ref1 = (ref = this.options.relayOptions) === null || ref === void 0 ? void 0 : ref.idFieldName) !== null && ref1 !== void 0 ? ref1 : 'id', (t)=>{
            var ref;
            return t.globalID({
                ...(ref = this.options.relayOptions) === null || ref === void 0 ? void 0 : ref.idFieldOptions,
                ...idOptions,
                nullable: false,
                args: {},
                resolve: async (parent, args, context, info)=>({
                        type: nodeConfig.name,
                        id: await resolve(parent, context)
                    })
            });
        });
    });
    this.configStore.associateRefWithName(nodeRef, typeName);
    return nodeRef;
};

//# sourceMappingURL=schema-builder.js.map