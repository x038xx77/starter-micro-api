/* eslint-disable no-nested-ternary */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    formatCursorChunk: ()=>formatCursorChunk,
    formatCursor: ()=>formatCursor,
    parseRawCursor: ()=>parseRawCursor,
    parseID: ()=>parseID,
    getDefaultIDSerializer: ()=>getDefaultIDSerializer,
    getDefaultIDParser: ()=>getDefaultIDParser,
    serializeID: ()=>serializeID,
    parseCompositeCursor: ()=>parseCompositeCursor,
    prismaCursorConnectionQuery: ()=>prismaCursorConnectionQuery,
    wrapConnectionResult: ()=>wrapConnectionResult,
    resolvePrismaCursorConnection: ()=>resolvePrismaCursorConnection,
    getCursorFormatter: ()=>getCursorFormatter,
    getCursorParser: ()=>getCursorParser
});
const _core = require("@pothos/core");
const _datamodel = require("./datamodel");
const DEFAULT_MAX_SIZE = 100;
const DEFAULT_SIZE = 20;
function formatCursorChunk(value) {
    if (value instanceof Date) {
        return `D:${String(Number(value))}`;
    }
    switch(typeof value){
        case 'number':
            return `N:${value}`;
        case 'string':
            return `S:${value}`;
        case 'bigint':
            return `I:${value}`;
        default:
            throw new TypeError(`Unsupported cursor type ${typeof value}`);
    }
}
function formatCursor(fields) {
    return (value)=>{
        if (typeof fields === 'string') {
            return (0, _core.encodeBase64)(`GPC:${formatCursorChunk(value[fields])}`);
        }
        return (0, _core.encodeBase64)(`GPC:J:${JSON.stringify(fields.map((name)=>value[name]))}`);
    };
}
function parseRawCursor(cursor) {
    if (typeof cursor !== 'string') {
        throw new TypeError('Cursor must be a string');
    }
    try {
        const decoded = (0, _core.decodeBase64)(cursor);
        const [, type, value] = decoded.match(/^GPC:(\w):(.*)/);
        switch(type){
            case 'S':
                return value;
            case 'N':
                return Number.parseInt(value, 10);
            case 'D':
                return new Date(Number.parseInt(value, 10));
            case 'J':
                return JSON.parse(value);
            case 'I':
                // eslint-disable-next-line node/no-unsupported-features/es-builtins
                return BigInt(value);
            default:
                throw new TypeError(`Invalid cursor type ${type}`);
        }
    } catch  {
        throw new Error(`Invalid cursor: ${cursor}`);
    }
}
function parseID(id, dataType) {
    if (!id) {
        return id;
    }
    switch(dataType){
        case 'String':
            return id;
        case 'Int':
            return Number.parseInt(id, 10);
        case 'BigInt':
            // eslint-disable-next-line node/no-unsupported-features/es-builtins
            return BigInt(id);
        case 'Boolean':
            return id !== 'false';
        case 'Float':
        case 'Decimal':
            return Number.parseFloat(id);
        case 'DateTime':
            return new Date(id);
        case 'Json':
            return JSON.parse(id);
        case 'Byte':
            return Buffer.from(id, 'base64');
        default:
            return id;
    }
}
function getDefaultIDSerializer(modelName, fieldName, builder) {
    var ref, ref1;
    const model = (0, _datamodel.getModel)(modelName, builder);
    const field = model.fields.find((f)=>f.name === fieldName);
    if (field) {
        return (parent)=>serializeID(parent[fieldName], field.type);
    }
    var ref2;
    if (((ref2 = (ref = model.primaryKey) === null || ref === void 0 ? void 0 : ref.name) !== null && ref2 !== void 0 ? ref2 : (ref1 = model.primaryKey) === null || ref1 === void 0 ? void 0 : ref1.fields.join('_')) === fieldName) {
        const fields = model.primaryKey.fields.map((n)=>model.fields.find((f)=>f.name === n));
        return (parent)=>JSON.stringify(fields.map((f)=>serializeID(parent[f.name], f.kind)));
    }
    var _name;
    const index = model.uniqueIndexes.find((idx)=>((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join('_')) === fieldName);
    if (index) {
        const fields1 = index.fields.map((n)=>model.fields.find((f)=>f.name === n));
        return (parent)=>JSON.stringify(fields1.map((f)=>serializeID(parent[f.name], f.kind)));
    }
    throw new Error(`Unable to find ${fieldName} for model ${modelName}`);
}
function getDefaultIDParser(modelName, fieldName, builder) {
    var ref, ref1;
    if (!fieldName) {
        throw new Error('Missing field name');
    }
    const model = (0, _datamodel.getModel)(modelName, builder);
    const field = model.fields.find((f)=>f.name === fieldName);
    if (field) {
        return (id)=>parseID(id, field.type);
    }
    var _name;
    const index = model.uniqueIndexes.find((idx)=>((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join('_')) === fieldName);
    let fields;
    var ref2;
    if (((ref2 = (ref = model.primaryKey) === null || ref === void 0 ? void 0 : ref.name) !== null && ref2 !== void 0 ? ref2 : (ref1 = model.primaryKey) === null || ref1 === void 0 ? void 0 : ref1.fields.join('_')) === fieldName) {
        fields = model.primaryKey.fields.map((n)=>model.fields.find((f)=>f.name === n));
    } else if (index) {
        fields = index.fields.map((n)=>model.fields.find((f)=>f.name === n));
    }
    if (!fields) {
        throw new Error(`Unable to find ${fieldName} for model ${modelName}`);
    }
    return (id)=>{
        const parts = JSON.parse(id);
        if (!Array.isArray(parts)) {
            throw new TypeError(`Invalid id received for ${fieldName} of ${modelName}`);
        }
        const result = {};
        for(let i = 0; i < fields.length; i += 1){
            result[fields[i].name] = parseID(parts[i], fields[i].type);
        }
        return result;
    };
}
function serializeID(id, dataType) {
    switch(dataType){
        case 'Json':
            return JSON.stringify(id);
        case 'Byte':
            return id.toString('base64');
        default:
            return String(id);
    }
}
function parseCompositeCursor(fields) {
    return (cursor)=>{
        const parsed = parseRawCursor(cursor);
        if (!Array.isArray(parsed)) {
            throw new TypeError(`Expected compound cursor to contain an array, but got ${parsed}`);
        }
        const record = {};
        fields.forEach((field, i)=>{
            record[field] = parsed[i];
        });
        return record;
    };
}
function prismaCursorConnectionQuery({ args , ctx , maxSize =DEFAULT_MAX_SIZE , defaultSize =DEFAULT_SIZE , parseCursor  }) {
    const { before , after , first , last  } = args;
    if (first != null && first < 0) {
        throw new TypeError('Argument "first" must be a non-negative integer');
    }
    if (last != null && last < 0) {
        throw new Error('Argument "last" must be a non-negative integer');
    }
    if (before && after) {
        throw new Error('Arguments "before" and "after" are not supported at the same time');
    }
    if (before != null && first != null) {
        throw new Error('Arguments "before" and "first" are not supported at the same time');
    }
    if (after != null && last != null) {
        throw new Error('Arguments "after" and "last" are not supported at the same time');
    }
    const cursor = before !== null && before !== void 0 ? before : after;
    const maxSizeForConnection = typeof maxSize === 'function' ? maxSize(args, ctx) : maxSize;
    const defaultSizeForConnection = typeof defaultSize === 'function' ? defaultSize(args, ctx) : defaultSize;
    var ref;
    let take = Math.min((ref = first !== null && first !== void 0 ? first : last) !== null && ref !== void 0 ? ref : defaultSizeForConnection, maxSizeForConnection) + 1;
    if (before) {
        take = -take;
    }
    return cursor == null ? {
        take,
        skip: 0
    } : {
        cursor: parseCursor(cursor),
        take,
        skip: 1
    };
}
function wrapConnectionResult(results, args, take, cursor, totalCount) {
    var ref, ref1;
    const gotFullResults = results.length === Math.abs(take);
    const hasNextPage = args.before ? true : gotFullResults;
    const hasPreviousPage = args.after ? true : args.before ? gotFullResults : false;
    const nodes = gotFullResults ? results.slice(take < 0 ? 1 : 0, take < 0 ? results.length : -1) : results;
    const edges = nodes.map((value, index)=>value == null ? null : {
            cursor: cursor(value),
            node: value
        });
    return {
        totalCount,
        edges,
        pageInfo: {
            startCursor: (ref = edges[0]) === null || ref === void 0 ? void 0 : ref.cursor,
            endCursor: (ref1 = edges[edges.length - 1]) === null || ref1 === void 0 ? void 0 : ref1.cursor,
            hasPreviousPage,
            hasNextPage
        }
    };
}
async function resolvePrismaCursorConnection(options, cursor, resolve) {
    const query = prismaCursorConnectionQuery(options);
    const results = await resolve({
        ...options.query,
        ...query
    });
    return wrapConnectionResult(results, options.args, query.take, cursor, options.totalCount);
}
function getCursorFormatter(name, builder, cursor) {
    var ref, ref1;
    const modelData = (0, _datamodel.getModel)(name, builder);
    var ref2;
    const primaryKey = (ref2 = (ref = modelData.primaryKey) === null || ref === void 0 ? void 0 : ref.name) !== null && ref2 !== void 0 ? ref2 : (ref1 = modelData.primaryKey) === null || ref1 === void 0 ? void 0 : ref1.fields.join('_');
    if (primaryKey === cursor) {
        return formatCursor(modelData.primaryKey.fields);
    }
    var _name;
    const uniqueIndex = modelData.uniqueIndexes.find((idx)=>((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join('_')) === cursor);
    var ref3;
    return formatCursor((ref3 = uniqueIndex === null || uniqueIndex === void 0 ? void 0 : uniqueIndex.fields) !== null && ref3 !== void 0 ? ref3 : cursor);
}
function getCursorParser(name, builder, cursor) {
    var ref, ref1;
    const modelData = (0, _datamodel.getModel)(name, builder);
    var ref2;
    const primaryKey = (ref2 = (ref = modelData.primaryKey) === null || ref === void 0 ? void 0 : ref.name) !== null && ref2 !== void 0 ? ref2 : (ref1 = modelData.primaryKey) === null || ref1 === void 0 ? void 0 : ref1.fields.join('_');
    let parser = parseRawCursor;
    if (primaryKey === cursor) {
        parser = parseCompositeCursor(modelData.primaryKey.fields);
    } else {
        var _name;
        const uniqueIndex = modelData.uniqueIndexes.find((idx)=>((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join('_')) === cursor);
        if (uniqueIndex) {
            parser = parseCompositeCursor(uniqueIndex.fields);
        }
    }
    return (rawCursor)=>({
            [cursor]: parser(rawCursor)
        });
}

//# sourceMappingURL=cursors.js.map