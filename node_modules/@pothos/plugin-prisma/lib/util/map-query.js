/* eslint-disable no-param-reassign */ /* eslint-disable no-continue */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    queryFromInfo: ()=>queryFromInfo,
    selectionStateFromInfo: ()=>selectionStateFromInfo,
    getIndirectType: ()=>getIndirectType
});
const _graphql = require("graphql");
const _loaderMap = require("./loader-map");
const _selections = require("./selections");
function addTypeSelectionsForField(type, context, info, state, selection, indirectPath) {
    if (selection.name.value.startsWith('__')) {
        return;
    }
    var _extensions;
    const { pothosPrismaInclude , pothosPrismaSelect , pothosPrismaIndirectInclude , pothosPrismaModel  } = (_extensions = type.extensions) !== null && _extensions !== void 0 ? _extensions : {};
    if (pothosPrismaIndirectInclude) {
        resolveIndirectInclude(type, info, selection, pothosPrismaIndirectInclude.path, indirectPath, (resolvedType, field, path)=>{
            addTypeSelectionsForField(resolvedType, context, info, state, field, path);
        });
    }
    if (!(0, _graphql.isObjectType)(type)) {
        return;
    }
    if (pothosPrismaModel && !pothosPrismaSelect) {
        state.mode = 'include';
    }
    if (pothosPrismaInclude || pothosPrismaSelect) {
        (0, _selections.mergeSelection)(state, {
            select: pothosPrismaSelect ? {
                ...pothosPrismaSelect
            } : undefined,
            include: pothosPrismaInclude ? {
                ...pothosPrismaInclude
            } : undefined
        });
    }
    if (selection.selectionSet) {
        addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
    }
}
function resolveIndirectInclude(type, info, selection, includePath, path, resolve) {
    const [include, ...rest] = includePath;
    if (!selection.selectionSet || !include) {
        return;
    }
    for (const sel of selection.selectionSet.selections){
        switch(sel.kind){
            case _graphql.Kind.FIELD:
                if (sel.name.value === include.name && (0, _graphql.isObjectType)(type)) {
                    const returnType = (0, _graphql.getNamedType)(type.getFields()[sel.name.value].type);
                    if (rest.length === 0) {
                        var ref;
                        var ref1;
                        resolve(returnType, sel, [
                            ...path,
                            (ref1 = (ref = sel.alias) === null || ref === void 0 ? void 0 : ref.value) !== null && ref1 !== void 0 ? ref1 : sel.name.value
                        ]);
                    } else {
                        var ref2;
                        var ref3;
                        resolveIndirectInclude(returnType, info, sel, rest, [
                            ...path,
                            (ref3 = (ref2 = sel.alias) === null || ref2 === void 0 ? void 0 : ref2.value) !== null && ref3 !== void 0 ? ref3 : sel.name.value
                        ], resolve);
                    }
                }
                continue;
            case _graphql.Kind.FRAGMENT_SPREAD:
                if (info.fragments[sel.name.value].typeCondition.name.value === include.type) {
                    resolveIndirectInclude(info.schema.getType(include.type), info, info.fragments[sel.name.value], includePath, path, resolve);
                }
                continue;
            case _graphql.Kind.INLINE_FRAGMENT:
                if (!sel.typeCondition || sel.typeCondition.name.value === include.type) {
                    resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve);
                }
                continue;
            default:
                throw new Error(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addNestedSelections(type, context, info, state, selections, indirectPath) {
    for (const selection of selections.selections){
        switch(selection.kind){
            case _graphql.Kind.FIELD:
                addFieldSelection(type, context, info, state, selection, indirectPath);
                continue;
            case _graphql.Kind.FRAGMENT_SPREAD:
                if (info.fragments[selection.name.value].typeCondition.name.value !== type.name) {
                    continue;
                }
                addNestedSelections(type, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath);
                continue;
            case _graphql.Kind.INLINE_FRAGMENT:
                if (selection.typeCondition && selection.typeCondition.name.value !== type.name) {
                    continue;
                }
                addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
                continue;
            default:
                throw new Error(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addFieldSelection(type, context, info, state, selection, indirectPath) {
    var ref;
    if (selection.name.value.startsWith('__')) {
        return;
    }
    const field = type.getFields()[selection.name.value];
    if (!field) {
        throw new Error(`Unknown field ${selection.name.value} on ${type.name}`);
    }
    const fieldSelect = (ref = field.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaSelect;
    let fieldSelectionMap;
    let mappings = {};
    if (typeof fieldSelect === 'function') {
        const args = (0, _graphql.getArgumentValues)(field, selection, info.variableValues);
        fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude)=>{
            const returnType = (0, _graphql.getNamedType)(field.type);
            const query = typeof rawQuery === 'function' ? rawQuery(args, context) : rawQuery;
            const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info)) : indirectInclude;
            const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state);
            if (typeof query === 'object' && Object.keys(query).length > 0) {
                (0, _selections.mergeSelection)(fieldState, {
                    select: {},
                    ...query
                });
            }
            if (normalizedIndirectInclude && normalizedIndirectInclude.path.length > 0) {
                var ref, ref1;
                var ref2;
                resolveIndirectInclude(returnType, info, selection, [
                    ...(ref2 = (ref1 = (ref = returnType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaIndirectInclude) === null || ref1 === void 0 ? void 0 : ref1.path) !== null && ref2 !== void 0 ? ref2 : [],
                    ...normalizedIndirectInclude.path
                ], [], (resolvedType, resolvedField, path)=>{
                    addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path);
                });
            }
            addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
            // eslint-disable-next-line prefer-destructuring
            mappings = fieldState.mappings;
            return (0, _selections.selectionToQuery)(fieldState);
        }, (path)=>{
            const returnType = (0, _graphql.getNamedType)(field.type);
            let node = null;
            resolveIndirectInclude(returnType, info, selection, path.map((name)=>({
                    name
                })), [], (_, resolvedField)=>{
                node = resolvedField;
            });
            return node;
        });
    } else {
        fieldSelectionMap = {
            select: fieldSelect
        };
    }
    if (fieldSelect && (0, _selections.selectionCompatible)(state, fieldSelectionMap, true)) {
        var ref1;
        (0, _selections.mergeSelection)(state, fieldSelectionMap);
        var ref2;
        state.mappings[(ref2 = (ref1 = selection.alias) === null || ref1 === void 0 ? void 0 : ref1.value) !== null && ref2 !== void 0 ? ref2 : selection.name.value] = {
            field: selection.name.value,
            type: type.name,
            mappings,
            indirectPath
        };
    }
}
function queryFromInfo({ context , info , typeName , select , path =[]  }) {
    const type = typeName ? info.schema.getTypeMap()[typeName] : (0, _graphql.getNamedType)(info.returnType);
    const state = createStateForType(type, info);
    if (select) {
        (0, _selections.mergeSelection)(state, {
            select
        });
    }
    if (path.length > 0) {
        resolveIndirectInclude((0, _graphql.getNamedType)(info.returnType), info, info.fieldNodes[0], path.map((n)=>typeof n === 'string' ? {
                name: n
            } : n), [], (resolvedType, resolvedField, nested)=>{
            addTypeSelectionsForField(resolvedType, context, info, state, resolvedField, nested);
        });
    } else {
        addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
    }
    (0, _loaderMap.setLoaderMappings)(context, info, state.mappings);
    return (0, _selections.selectionToQuery)(state);
}
function selectionStateFromInfo(context, info, typeName) {
    const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
    const state = createStateForType(type, info);
    if (!(0, _graphql.isObjectType)(type)) {
        throw new Error('Prisma plugin can only resolve includes for object types');
    }
    addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
    return state;
}
function createStateForType(type, info, parent) {
    var ref, ref1;
    const targetType = getIndirectType(type, info);
    const fieldMap = (ref = targetType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaFieldMap;
    return (0, _selections.createState)(fieldMap, ((ref1 = targetType.extensions) === null || ref1 === void 0 ? void 0 : ref1.pothosPrismaSelect) ? 'select' : 'include', parent);
}
function getIndirectType(type, info) {
    var ref;
    let targetType = type;
    while((ref = targetType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaIndirectInclude){
        var ref1;
        targetType = info.schema.getType(((ref1 = targetType.extensions) === null || ref1 === void 0 ? void 0 : ref1.pothosPrismaIndirectInclude).getType());
    }
    return targetType;
}
function normalizeInclude(path, type) {
    let currentType = type;
    const normalized = [];
    if (!(0, _graphql.isObjectType)(currentType)) {
        throw new Error(`Expected ${currentType} to be an Object type`);
    }
    for (const fieldName of path){
        const field = currentType.getFields()[fieldName];
        if (!field) {
            throw new Error(`Expected ${currentType} to have a field ${fieldName}`);
        }
        currentType = (0, _graphql.getNamedType)(field.type);
        if (!(0, _graphql.isObjectType)(currentType)) {
            throw new Error(`Expected ${currentType} to be an Object type`);
        }
        normalized.push({
            name: fieldName,
            type: currentType.name
        });
    }
    return {
        getType: ()=>normalized.length > 0 ? normalized[normalized.length - 1].type : type.name,
        path: normalized
    };
}

//# sourceMappingURL=map-query.js.map