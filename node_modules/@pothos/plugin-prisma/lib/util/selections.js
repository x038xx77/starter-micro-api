/* eslint-disable no-param-reassign */ /* eslint-disable no-underscore-dangle */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
function _export(target, all) {
    for(var name in all)Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
    });
}
_export(exports, {
    selectionCompatible: ()=>selectionCompatible,
    stateCompatible: ()=>stateCompatible,
    mergeState: ()=>mergeState,
    createState: ()=>createState,
    mergeSelection: ()=>mergeSelection,
    selectionToQuery: ()=>selectionToQuery
});
const _deepEqual = require("./deep-equal");
function selectionCompatible(state, selectionMap, ignoreQuery = false) {
    if (typeof selectionMap === 'boolean') {
        return ignoreQuery || !selectionMap || Object.keys(state.query).length === 0;
    }
    const { select , include , ...query } = selectionMap;
    if (select && Object.keys(select).some((key)=>compare(key, select[key]))) {
        return false;
    }
    if (include && Object.keys(include).some((key)=>compare(key, include[key]))) {
        return false;
    }
    return ignoreQuery || (0, _deepEqual.deepEqual)(state.query, query);
    function compare(key, value) {
        if (key === '_count') {
            const selections = value && value.select;
            const keys = selections && Object.keys(selections);
            if (!keys || keys.length === 0) {
                return false;
            }
            return keys.some((k)=>state.counts.has(k) && !(0, _deepEqual.deepEqual)(state.counts.get(k), selections[k]));
        }
        return value && state.fieldMap.relations.has(key) && state.relations.has(key) && !selectionCompatible(state.relations.get(key), value);
    }
}
function stateCompatible(state, newState, ignoreQuery = false) {
    for (const [name, relationState] of newState.relations){
        if (state.relations.has(name) && !stateCompatible(state.relations.get(name), relationState)) {
            return false;
        }
    }
    return ignoreQuery || (0, _deepEqual.deepEqual)(state.query, newState.query);
}
function mergeState(state, newState) {
    for (const [name, relationState] of newState.relations){
        if (state.relations.has(name)) {
            mergeState(state.relations.get(name), relationState);
        }
    }
    if (newState.mode === 'include') {
        state.mode = 'include';
    } else {
        for (const name1 of newState.fields){
            state.fields.add(name1);
        }
    }
}
function createState(fieldMap, mode, parent) {
    return {
        parent,
        mode,
        fieldMap,
        query: {},
        fields: new Set(),
        counts: new Map(),
        relations: new Map(),
        mappings: {}
    };
}
function mergeSelection(state, { select , include , ...query }) {
    if (state.mode === 'select' && !select) {
        state.mode = 'include';
    }
    if (include) {
        Object.keys(include).forEach((key)=>{
            merge(key, include[key]);
        });
    }
    if (select) {
        Object.keys(select).forEach((key)=>{
            merge(key, select[key]);
        });
    }
    if (Object.keys(query).length > 0) {
        state.query = query;
    }
    function merge(key, value) {
        if (!value) {
            return;
        }
        if (key === '_count') {
            var _select;
            const counts = (_select = value.select) !== null && _select !== void 0 ? _select : {};
            Object.keys(counts).forEach((count)=>{
                state.counts.set(count, counts[count]);
            });
            return;
        }
        const selection = value === true ? {
            include: {}
        } : value;
        const childMap = state.fieldMap.relations.get(key);
        if (childMap) {
            if (state.relations.has(key)) {
                mergeSelection(state.relations.get(key), selection);
            } else {
                const relatedState = createState(childMap, 'select');
                mergeSelection(relatedState, selection);
                state.relations.set(key, relatedState);
            }
        } else {
            state.fields.add(key);
        }
    }
}
function selectionToQuery(state) {
    const nestedIncludes = {};
    const counts = {};
    let hasSelection = false;
    state.relations.forEach((sel, relation)=>{
        hasSelection = true;
        const nested = selectionToQuery(sel);
        nestedIncludes[relation] = Object.keys(nested).length > 0 ? nested : true;
    });
    if (state.counts.size > 0) {
        hasSelection = true;
        for (const [count, selection] of state.counts){
            counts[count] = selection;
        }
        nestedIncludes._count = {
            select: counts
        };
    }
    if (state.mode === 'select') {
        state.fields.forEach((field)=>{
            hasSelection = true;
            nestedIncludes[field] = true;
        });
        return {
            ...state.query,
            select: nestedIncludes
        };
    }
    return hasSelection ? {
        ...state.query,
        include: nestedIncludes
    } : state.query;
}

//# sourceMappingURL=selections.js.map