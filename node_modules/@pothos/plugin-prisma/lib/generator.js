/* eslint-disable unicorn/prefer-module */ /* eslint-disable node/prefer-promises/fs */ /* eslint-disable no-magic-numbers */ /* eslint-disable no-nested-ternary */ "use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
const _fs = require("fs");
const _path = require("path");
const _typescript = /*#__PURE__*/ _interopRequireWildcard(require("typescript"));
const _generatorHelper = require("@prisma/generator-helper");
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
const MIN_TS_VERSION = [
    4,
    5,
    2
];
function checkTSVersion() {
    const versionParts = _typescript.version.split(/[.-]/g);
    for(let i = 0; i < 3; i += 1){
        const part = Number.parseInt(versionParts[i], 10);
        if (part < MIN_TS_VERSION[i]) {
            throw new Error(`@pothos/plugin-prisma requires typescript version >${MIN_TS_VERSION.join('.')}`);
        }
        if (part > MIN_TS_VERSION[i]) {
            return;
        }
    }
}
const defaultOutput = (0, _path.resolve)(__dirname, '../generated.ts');
(0, _generatorHelper.generatorHandler)({
    onManifest: ()=>({
            prettyName: 'Pothos integration',
            requiresGenerators: [
                'prisma-client-js'
            ],
            defaultOutput
        }),
    onGenerate: async (options)=>{
        checkTSVersion();
        const config = options.generator.config;
        var _clientOutput;
        const prismaLocation = (_clientOutput = config.clientOutput) !== null && _clientOutput !== void 0 ? _clientOutput : options.otherGenerators.find((gen)=>gen.provider.value === 'prisma-client-js').output.value;
        const importStatement = _typescript.default.factory.createImportDeclaration([], [], _typescript.default.factory.createImportClause(true, undefined, _typescript.default.factory.createNamedImports([
            _typescript.default.factory.createImportSpecifier(false, undefined, _typescript.default.factory.createIdentifier('Prisma')),
            ...options.dmmf.datamodel.models.map((model)=>_typescript.default.factory.createImportSpecifier(false, undefined, _typescript.default.factory.createIdentifier(model.name)))
        ])), _typescript.default.factory.createStringLiteral(prismaLocation));
        function getOrderByTypeName(type) {
            var ref;
            const possibleTypes = [
                `${type}OrderByWithRelationInput`,
                `${type}OrderByWithRelationAndSearchRelevanceInput`
            ];
            const orderBy = (ref = options.dmmf.schema.inputObjectTypes.prisma) === null || ref === void 0 ? void 0 : ref.find((inputType)=>possibleTypes.includes(inputType.name));
            if (!orderBy) {
                return possibleTypes[0];
            }
            return orderBy.name;
        }
        const modelTypes = options.dmmf.datamodel.models.map((model)=>{
            const relations = model.fields.filter((field)=>!!field.relationName);
            const listRelations = model.fields.filter((field)=>!!field.relationName && field.isList);
            return _typescript.default.factory.createPropertySignature([], model.name, undefined, _typescript.default.factory.createTypeLiteralNode([
                _typescript.default.factory.createPropertySignature([], 'Name', undefined, _typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(model.name))),
                _typescript.default.factory.createPropertySignature([], 'Shape', undefined, _typescript.default.factory.createTypeReferenceNode(model.name)),
                _typescript.default.factory.createPropertySignature([], 'Include', undefined, relations.length > 0 ? _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}Include`) : _typescript.default.factory.createTypeReferenceNode('never')),
                _typescript.default.factory.createPropertySignature([], 'Select', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}Select`)),
                _typescript.default.factory.createPropertySignature([], 'OrderBy', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${getOrderByTypeName(model.name)}`)),
                _typescript.default.factory.createPropertySignature([], 'WhereUnique', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}WhereUniqueInput`)),
                _typescript.default.factory.createPropertySignature([], 'Where', undefined, _typescript.default.factory.createTypeReferenceNode(`Prisma.${model.name}WhereInput`)),
                _typescript.default.factory.createPropertySignature([], 'RelationName', undefined, relations.length > 0 ? _typescript.default.factory.createUnionTypeNode(relations.map((field)=>_typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(field.name)))) : _typescript.default.factory.createTypeReferenceNode('never')),
                _typescript.default.factory.createPropertySignature([], 'ListRelations', undefined, listRelations.length > 0 ? _typescript.default.factory.createUnionTypeNode(listRelations.map((field)=>_typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(field.name)))) : _typescript.default.factory.createTypeReferenceNode('never')),
                _typescript.default.factory.createPropertySignature([], 'Relations', undefined, _typescript.default.factory.createTypeLiteralNode(relations.map((field)=>{
                    const typeName = field.type;
                    return _typescript.default.factory.createPropertySignature([], field.name, undefined, _typescript.default.factory.createTypeLiteralNode([
                        _typescript.default.factory.createPropertySignature([], 'Shape', undefined, field.isList ? _typescript.default.factory.createArrayTypeNode(_typescript.default.factory.createTypeReferenceNode(typeName)) : field.isRequired ? _typescript.default.factory.createTypeReferenceNode(typeName) : _typescript.default.factory.createUnionTypeNode([
                            _typescript.default.factory.createTypeReferenceNode(typeName),
                            _typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createNull())
                        ])),
                        _typescript.default.factory.createPropertySignature([], 'Types', undefined, _typescript.default.factory.createIndexedAccessTypeNode(_typescript.default.factory.createTypeReferenceNode('PrismaTypes'), _typescript.default.factory.createLiteralTypeNode(_typescript.default.factory.createStringLiteral(typeName))))
                    ]));
                })))
            ]));
        });
        const prismaTypes = _typescript.default.factory.createInterfaceDeclaration([], [
            _typescript.default.factory.createModifier(_typescript.SyntaxKind.ExportKeyword),
            _typescript.default.factory.createModifier(_typescript.SyntaxKind.DefaultKeyword)
        ], 'PrismaTypes', [], [], modelTypes);
        const printer = _typescript.default.createPrinter({});
        const sourcefile = _typescript.default.createSourceFile(options.generator.output.value, '', _typescript.ScriptTarget.ESNext, false, _typescript.ScriptKind.TS);
        const nodes = _typescript.default.factory.createNodeArray([
            importStatement,
            prismaTypes
        ]);
        const result = printer.printList(_typescript.ListFormat.SourceFileStatements, nodes, sourcefile);
        await new Promise((resolve, reject)=>{
            (0, _fs.mkdir)((0, _path.dirname)(sourcefile.fileName), {
                recursive: true
            }, (err)=>{
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
        return new Promise((resolve, reject)=>{
            (0, _fs.writeFile)(sourcefile.fileName, `/* eslint-disable */\n${result}`, (err)=>{
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }
});

//# sourceMappingURL=generator.js.map