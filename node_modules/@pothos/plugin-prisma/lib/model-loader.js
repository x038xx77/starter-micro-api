"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "ModelLoader", {
    enumerable: true,
    get: ()=>ModelLoader
});
const _core = require("@pothos/core");
const _datamodel = require("./util/datamodel");
const _getClient = require("./util/get-client");
const _selections = require("./util/selections");
class ModelLoader {
    static forRef(ref, modelName, findUnique, builder) {
        return (0, _core.createContextCache)((model)=>new ModelLoader(model, builder, modelName, findUnique === null ? ()=>{
                throw new Error(`Missing findUnique for ${ref.name}`);
            } : findUnique !== null && findUnique !== void 0 ? findUnique : this.getDefaultFindUnique(ref, modelName, builder)));
    }
    static getFindUnique(findBy) {
        if (typeof findBy === 'string') {
            return (parent)=>({
                    [findBy]: parent[findBy]
                });
        }
        const { fields , name: primaryKeyName  } = findBy;
        return (parent)=>{
            const primaryKey = {};
            for (const key of fields){
                primaryKey[key] = parent[key];
            }
            return {
                [primaryKeyName !== null && primaryKeyName !== void 0 ? primaryKeyName : fields.join('_')]: primaryKey
            };
        };
    }
    static getDefaultFindBy(ref, modelName, builder) {
        const model = (0, _datamodel.getModel)(modelName, builder);
        const idField = model.fields.find((field)=>field.isId);
        const uniqueField = model.fields.find((field)=>field.isRequired && field.isUnique);
        const uniqueIndex = model.uniqueIndexes.find((idx)=>{
            return idx.fields.every((field)=>{
                var ref;
                return (ref = model.fields.find((f)=>f.name === field)) === null || ref === void 0 ? void 0 : ref.isRequired;
            });
        });
        let findBy;
        if (model.primaryKey) {
            findBy = model.primaryKey;
        } else if (idField) {
            findBy = idField.name;
        } else if (uniqueField) {
            findBy = uniqueField.name;
        } else if (uniqueIndex) {
            findBy = uniqueIndex;
        }
        if (!findBy) {
            throw new Error(`Missing findUnique for ${ref.name}`);
        }
        return findBy;
    }
    static getDefaultFindUnique(ref, modelName, builder) {
        const findBy = this.getDefaultFindBy(ref, modelName, builder);
        return this.getFindUnique(findBy);
    }
    static getDefaultIDSelection(ref, modelName, builder) {
        const findBy = this.getDefaultFindBy(ref, modelName, builder);
        if (typeof findBy === 'string') {
            return {
                [findBy]: true
            };
        }
        const result = {};
        for (const field of findBy.fields){
            result[field] = true;
        }
        return result;
    }
    static getCursorSelection(ref, modelName, cursor, builder) {
        const model = (0, _datamodel.getModel)(modelName, builder);
        const field = model.fields.find((field)=>field.name === cursor);
        if (field) {
            return {
                [field.name]: true
            };
        }
        var _name;
        const index = [
            model.primaryKey,
            ...model.uniqueIndexes
        ].filter(Boolean).find((idx)=>((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join('_')) === cursor);
        if (!index) {
            throw new Error(`Can't find "${cursor}" field or index for ${ref.name}`);
        }
        const selection = {};
        for (const column of index.fields){
            selection[column] = true;
        }
        return selection;
    }
    static getFindUniqueForField(ref, modelName, fieldName, builder) {
        var ref1, ref2;
        const model = (0, _datamodel.getModel)(modelName, builder);
        var _name;
        const uniqueIndex = model.uniqueIndexes.find((idx)=>((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join('_')) === fieldName);
        let findBy;
        var ref3;
        if (model.fields.some((field)=>field.name === fieldName)) {
            findBy = fieldName;
        } else if (model.primaryKey && ((ref3 = (ref1 = model.primaryKey) === null || ref1 === void 0 ? void 0 : ref1.name) !== null && ref3 !== void 0 ? ref3 : (ref2 = model.primaryKey) === null || ref2 === void 0 ? void 0 : ref2.fields.join('_')) === fieldName) {
            findBy = model.primaryKey;
        } else if (uniqueIndex) {
            findBy = uniqueIndex;
        }
        if (!findBy) {
            throw new Error(`Unable to find field or index for ${fieldName} of ${ref.name}`);
        }
        return this.getFindUnique(findBy);
    }
    async loadSelection(selection, context) {
        const query = (0, _selections.selectionToQuery)(selection);
        for (const entry of this.staged){
            if ((0, _selections.selectionCompatible)(entry.state, query)) {
                (0, _selections.mergeSelection)(entry.state, query);
                return entry.promise;
            }
        }
        return this.initLoad(selection, context);
    }
    async initLoad(state, context) {
        const entry = {
            promise: Promise.resolve().then(()=>{
                this.staged.delete(entry);
                const delegate = (0, _datamodel.getDelegateFromModel)((0, _getClient.getClient)(this.builder, context), this.modelName);
                if (delegate.findUniqueOrThrow) {
                    return delegate.findUniqueOrThrow({
                        ...(0, _selections.selectionToQuery)(state),
                        where: {
                            ...this.findUnique(this.model, context)
                        }
                    });
                }
                return delegate.findUnique({
                    rejectOnNotFound: true,
                    ...(0, _selections.selectionToQuery)(state),
                    where: {
                        ...this.findUnique(this.model, context)
                    }
                });
            }),
            state
        };
        this.staged.add(entry);
        return entry.promise;
    }
    constructor(model, builder, modelName, findUnique){
        this.staged = new Set();
        this.model = model;
        this.builder = builder;
        this.findUnique = findUnique;
        this.modelName = modelName;
    }
}

//# sourceMappingURL=model-loader.js.map