import { createContextCache } from '@pothos/core';
import { getDelegateFromModel, getModel } from './util/datamodel.js';
import { getClient } from './util/get-client.js';
import { mergeSelection, selectionCompatible, selectionToQuery } from './util/selections.js';
export class ModelLoader {
    static forRef(ref, modelName, findUnique, builder) {
        return createContextCache((model) => new ModelLoader(model, builder, modelName, findUnique === null ? () => {
            throw new Error(`Missing findUnique for ${ref.name}`);
        } : findUnique !== null && findUnique !== void 0 ? findUnique : this.getDefaultFindUnique(ref, modelName, builder)));
    }
    static getFindUnique(findBy) {
        if (typeof findBy === "string") {
            return (parent) => ({
                [findBy]: parent[findBy]
            });
        }
        const { fields, name: primaryKeyName } = findBy;
        return (parent) => {
            const primaryKey = {};
            for (const key of fields) {
                primaryKey[key] = parent[key];
            }
            return {
                [primaryKeyName !== null && primaryKeyName !== void 0 ? primaryKeyName : fields.join("_")]: primaryKey
            };
        };
    }
    static getDefaultFindBy(ref, modelName, builder) {
        const model = getModel(modelName, builder);
        const idField = model.fields.find((field) => field.isId);
        const uniqueField = model.fields.find((field) => field.isRequired && field.isUnique);
        const uniqueIndex = model.uniqueIndexes.find((idx) => {
            return idx.fields.every((field) => {
                var ref;
                return (ref = model.fields.find((f) => f.name === field)) === null || ref === void 0 ? void 0 : ref.isRequired;
            });
        });
        let findBy;
        if (model.primaryKey) {
            findBy = model.primaryKey;
        }
        else if (idField) {
            findBy = idField.name;
        }
        else if (uniqueField) {
            findBy = uniqueField.name;
        }
        else if (uniqueIndex) {
            findBy = uniqueIndex;
        }
        if (!findBy) {
            throw new Error(`Missing findUnique for ${ref.name}`);
        }
        return findBy;
    }
    static getDefaultFindUnique(ref, modelName, builder) {
        const findBy = this.getDefaultFindBy(ref, modelName, builder);
        return this.getFindUnique(findBy);
    }
    static getDefaultIDSelection(ref, modelName, builder) {
        const findBy = this.getDefaultFindBy(ref, modelName, builder);
        if (typeof findBy === "string") {
            return {
                [findBy]: true
            };
        }
        const result = {};
        for (const field of findBy.fields) {
            result[field] = true;
        }
        return result;
    }
    static getCursorSelection(ref, modelName, cursor, builder) {
        const model = getModel(modelName, builder);
        const field = model.fields.find((field) => field.name === cursor);
        if (field) {
            return {
                [field.name]: true
            };
        }
        var _name;
        const index = [
            model.primaryKey,
            ...model.uniqueIndexes
        ].filter(Boolean).find((idx) => ((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join("_")) === cursor);
        if (!index) {
            throw new Error(`Can't find "${cursor}" field or index for ${ref.name}`);
        }
        const selection = {};
        for (const column of index.fields) {
            selection[column] = true;
        }
        return selection;
    }
    static getFindUniqueForField(ref, modelName, fieldName, builder) {
        var ref1, ref2;
        const model = getModel(modelName, builder);
        var _name;
        const uniqueIndex = model.uniqueIndexes.find((idx) => ((_name = idx.name) !== null && _name !== void 0 ? _name : idx.fields.join("_")) === fieldName);
        let findBy;
        var ref3;
        if (model.fields.some((field) => field.name === fieldName)) {
            findBy = fieldName;
        }
        else if (model.primaryKey && ((ref3 = (ref1 = model.primaryKey) === null || ref1 === void 0 ? void 0 : ref1.name) !== null && ref3 !== void 0 ? ref3 : (ref2 = model.primaryKey) === null || ref2 === void 0 ? void 0 : ref2.fields.join("_")) === fieldName) {
            findBy = model.primaryKey;
        }
        else if (uniqueIndex) {
            findBy = uniqueIndex;
        }
        if (!findBy) {
            throw new Error(`Unable to find field or index for ${fieldName} of ${ref.name}`);
        }
        return this.getFindUnique(findBy);
    }
    async loadSelection(selection, context) {
        const query = selectionToQuery(selection);
        for (const entry of this.staged) {
            if (selectionCompatible(entry.state, query)) {
                mergeSelection(entry.state, query);
                return entry.promise;
            }
        }
        return this.initLoad(selection, context);
    }
    async initLoad(state, context) {
        const entry = {
            promise: Promise.resolve().then(() => {
                this.staged.delete(entry);
                const delegate = getDelegateFromModel(getClient(this.builder, context), this.modelName);
                if (delegate.findUniqueOrThrow) {
                    return delegate.findUniqueOrThrow({
                        ...selectionToQuery(state),
                        where: {
                            ...this.findUnique(this.model, context)
                        }
                    });
                }
                return delegate.findUnique({
                    rejectOnNotFound: true,
                    ...selectionToQuery(state),
                    where: {
                        ...this.findUnique(this.model, context)
                    }
                });
            }),
            state
        };
        this.staged.add(entry);
        return entry.promise;
    }
    constructor(model, builder, modelName, findUnique) {
        this.staged = new Set();
        this.model = model;
        this.builder = builder;
        this.findUnique = findUnique;
        this.modelName = modelName;
    }
}
//# sourceMappingURL=model-loader.js.map
