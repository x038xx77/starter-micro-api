/* eslint-disable no-nested-ternary */ /* eslint-disable no-underscore-dangle */ import { isThenable, RootFieldBuilder } from '@pothos/core';
import { ModelLoader } from './model-loader.js';
import { getCursorFormatter, getCursorParser, prismaCursorConnectionQuery, wrapConnectionResult } from './util/cursors.js';
import { getRefFromModel, getRelation } from './util/datamodel.js';
import { getFieldDescription } from './util/description.js';
// Workaround for FieldKind not being extended on Builder classes
const RootBuilder = RootFieldBuilder;
export class PrismaObjectFieldBuilder extends RootBuilder {
    relation(name, ...allArgs) {
        const [{ description, ...options } = {}] = allArgs;
        const relationField = getRelation(this.model, this.builder, name);
        var _type;
        const ref = (_type = options.type) !== null && _type !== void 0 ? _type : getRefFromModel(relationField.type, this.builder);
        const { query = {}, resolve, extensions, ...rest } = options;
        const relationSelect = (args, context, nestedQuery) => ({
            select: {
                [name]: nestedQuery(query)
            }
        });
        return this.field({
            ...rest,
            type: relationField.isList ? [
                ref
            ] : ref,
            description: getFieldDescription(this.model, this.builder, name, description),
            extensions: {
                ...extensions,
                pothosPrismaSelect: relationSelect,
                pothosPrismaLoaded: (value) => value[name] !== undefined,
                pothosPrismaFallback: resolve && ((q, parent, args, context, info) => resolve({
                    ...q,
                    ...typeof query === "function" ? query(args, context) : query
                }, parent, args, context, info))
            },
            resolve: (parent) => parent[name]
        });
    }
    relationCount(name, ...allArgs) {
        const [{ where, ...options } = {}] = allArgs;
        const { resolve, ...rest } = options;
        const countSelect = typeof where === "function" ? (args, context) => ({
            _count: {
                select: {
                    [name]: {
                        where: where(args, context)
                    }
                }
            }
        }) : {
            _count: {
                select: {
                    [name]: where ? {
                        where
                    } : true
                }
            }
        };
        return this.field({
            ...rest,
            type: "Int",
            nullable: false,
            select: countSelect,
            resolve: (parent, args, context, info) => {
                var ref;
                return (ref = parent._count) === null || ref === void 0 ? void 0 : ref[name];
            }
        });
    }
    variant(variant, ...allArgs) {
        const [{ isNull, nullable, ...options } = {}] = allArgs;
        const ref = typeof variant === "string" ? getRefFromModel(variant, this.builder) : variant;
        const selfSelect = (args, context, nestedQuery) => nestedQuery({});
        return this.field({
            ...options,
            type: ref,
            extensions: {
                ...options === null || options === void 0 ? void 0 : options.extensions,
                pothosPrismaSelect: selfSelect
            },
            nullable: nullable !== null && nullable !== void 0 ? nullable : !!isNull,
            resolve: isNull ? (parent, args, context, info) => {
                const parentIsNull = isNull(parent, args, context, info);
                if (parentIsNull) {
                    if (isThenable(parentIsNull)) {
                        return parentIsNull.then((resolved) => resolved ? null : parent);
                    }
                    return null;
                }
                return parent;
            } : (parent) => parent
        });
    }
    expose(...args) {
        var ref;
        const [name, options = {}] = args;
        const typeConfig = this.builder.configStore.getTypeConfig(this.typename, "Object");
        const usingSelect = !!((ref = typeConfig.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaSelect);
        return this.exposeField(name, {
            ...options,
            extensions: {
                ...options.extensions,
                pothosPrismaVariant: name,
                pothosPrismaSelect: usingSelect && {
                    [name]: true
                }
            }
        });
    }
    createExpose(type) {
        return (...args) => {
            const [name, { description, ...options } = {}] = args;
            return this.expose(name, {
                ...options,
                description: getFieldDescription(this.model, this.builder, name, description),
                type
            });
        };
    }
    constructor(name, builder, model, fieldMap) {
        super(name, builder, "PrismaObject", "Object");
        this.exposeBoolean = this.createExpose("Boolean");
        this.exposeFloat = this.createExpose("Float");
        this.exposeInt = this.createExpose("Int");
        this.exposeID = this.createExpose("ID");
        this.exposeString = this.createExpose("String");
        this.exposeBooleanList = this.createExpose([
            "Boolean"
        ]);
        this.exposeFloatList = this.createExpose([
            "Float"
        ]);
        this.exposeIntList = this.createExpose([
            "Int"
        ]);
        this.exposeIDList = this.createExpose([
            "ID"
        ]);
        this.exposeStringList = this.createExpose([
            "String"
        ]);
        this.withAuth = withAuth;
        this.relatedConnection = function relatedConnection(name, { maxSize, defaultSize, cursor, query, resolve, extensions, totalCount, description, ...options }, connectionOptions = {}, edgeOptions = {}) {
            const relationField = getRelation(this.model, this.builder, name);
            var _type;
            const ref = (_type = options.type) !== null && _type !== void 0 ? _type : getRefFromModel(relationField.type, this.builder);
            let typeName;
            const formatCursor = getCursorFormatter(relationField.type, this.builder, cursor);
            const parseCursor = getCursorParser(relationField.type, this.builder, cursor);
            const getQuery = (args, ctx) => ({
                ...typeof query === "function" ? query(args, ctx) : query,
                ...prismaCursorConnectionQuery({
                    parseCursor,
                    ctx,
                    maxSize,
                    defaultSize,
                    args
                })
            });
            const cursorSelection = ModelLoader.getCursorSelection(ref, relationField.type, cursor, this.builder);
            const relationSelect = (args, context, nestedQuery, getSelection) => {
                const nested = nestedQuery(getQuery(args, context), {
                    getType: () => {
                        if (!typeName) {
                            typeName = this.builder.configStore.getTypeConfig(ref).name;
                        }
                        return typeName;
                    },
                    path: [
                        {
                            name: "edges"
                        },
                        {
                            name: "node"
                        }
                    ]
                });
                const hasTotalCount = totalCount && !!getSelection([
                    "totalCount"
                ]);
                const countSelect = this.builder.options.prisma.filterConnectionTotalCount ? nested.where ? {
                    where: nested.where
                } : true : true;
                return {
                    select: {
                        ...hasTotalCount ? {
                            _count: {
                                select: {
                                    [name]: countSelect
                                }
                            }
                        } : {},
                        [name]: (nested === null || nested === void 0 ? void 0 : nested.select) ? {
                            ...nested,
                            select: {
                                ...cursorSelection,
                                ...nested.select
                            }
                        } : nested
                    }
                };
            };
            const fieldRef = this.connection({
                ...options,
                description: getFieldDescription(this.model, this.builder, name, description),
                extensions: {
                    ...extensions,
                    pothosPrismaSelect: relationSelect,
                    pothosPrismaLoaded: (value) => value[name] !== undefined,
                    pothosPrismaFallback: resolve && ((q, parent, args, context, info) => Promise.resolve(resolve({
                        ...q,
                        ...getQuery(args, context)
                    }, parent, args, context, info)).then((result) => wrapConnectionResult(result, args, q.take, formatCursor)))
                },
                type: ref,
                resolve: (parent, args, context) => {
                    var ref;
                    const connectionQuery = getQuery(args, context);
                    return wrapConnectionResult(parent[name], args, connectionQuery.take, formatCursor, (ref = parent._count) === null || ref === void 0 ? void 0 : ref[name]);
                }
            }, {
                ...connectionOptions,
                fields: totalCount ? (t) => {
                    var ref;
                    return {
                        totalCount: t.int({
                            nullable: false,
                            resolve: (parent, args, context) => parent.totalCount
                        }),
                        ...(ref = connectionOptions.fields) === null || ref === void 0 ? void 0 : ref.call(connectionOptions, t)
                    };
                } : connectionOptions.fields
            }, edgeOptions);
            return fieldRef;
        };
        this.model = model;
        this.prismaFieldMap = fieldMap;
    }
}
function addScopes(scopes, builder) {
    const originalCreateField = builder.createField;
    // eslint-disable-next-line no-param-reassign
    builder.createField = function createField(options) {
        return originalCreateField.call(this, {
            authScopes: scopes,
            ...options
        });
    };
    return builder;
}
function withAuth(scopes) {
    return addScopes(scopes, new PrismaObjectFieldBuilder(this.typename, this.builder, this.model, this.prismaFieldMap));
}
//# sourceMappingURL=prisma-field-builder.js.map
