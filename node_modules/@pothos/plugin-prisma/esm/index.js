import './global-types.js';
import './schema-builder.js';
import SchemaBuilder, { BasePlugin } from '@pothos/core';
import { PrismaObjectFieldBuilder as InternalPrismaObjectFieldBuilder } from './field-builder.js';
import { getLoaderMapping, setLoaderMappings } from './util/loader-map.js';
import { queryFromInfo, selectionStateFromInfo } from './util/map-query.js';
export * from './types.js';
const pluginName = "prisma";
export default pluginName;
export { queryFromInfo };
export const ObjectFieldBuilder = InternalPrismaObjectFieldBuilder;
export class PrismaPlugin extends BasePlugin {
    onOutputFieldConfig(fieldConfig) {
        if (fieldConfig.kind === "PrismaObject" && fieldConfig.pothosOptions.select) {
            const { select } = fieldConfig.pothosOptions;
            return {
                ...fieldConfig,
                extensions: {
                    ...fieldConfig.extensions,
                    pothosPrismaSelect: typeof select === "function" ? (args, ctx, nestedQuery) => ({
                        select: select(args, ctx, nestedQuery)
                    }) : select
                }
            };
        }
        return fieldConfig;
    }
    wrapResolve(resolver, fieldConfig) {
        var ref, ref1, ref2, ref3;
        if (fieldConfig.kind !== "PrismaObject" || !((ref = fieldConfig.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaSelect)) {
            return resolver;
        }
        const parentConfig = this.buildCache.getTypeConfig(fieldConfig.parentType, "Object");
        const loadedCheck = (ref1 = fieldConfig.extensions) === null || ref1 === void 0 ? void 0 : ref1.pothosPrismaLoaded;
        const loaderCache = (ref2 = parentConfig.extensions) === null || ref2 === void 0 ? void 0 : ref2.pothosPrismaLoader;
        const fallback = (ref3 = fieldConfig.extensions) === null || ref3 === void 0 ? void 0 : ref3.pothosPrismaFallback;
        return (parent, args, context, info) => {
            const mapping = getLoaderMapping(context, info.path, info.parentType.name);
            if ((!loadedCheck || loadedCheck(parent)) && mapping) {
                setLoaderMappings(context, info, mapping);
                return resolver(parent, args, context, info);
            }
            if (fallback) {
                return fallback(queryFromInfo({
                    context,
                    info
                }), parent, args, context, info);
            }
            const selectionState = selectionStateFromInfo(context, info);
            return loaderCache(parent).loadSelection(selectionState, context).then((result) => {
                const mappings = selectionState.mappings[info.path.key];
                if (mappings) {
                    setLoaderMappings(context, info, mappings.mappings);
                }
                return resolver(result, args, context, info);
            });
        };
    }
    constructor(cache) {
        super(cache, pluginName);
    }
}
SchemaBuilder.registerPlugin(pluginName, PrismaPlugin);
//# sourceMappingURL=index.js.map
