/* eslint-disable no-param-reassign */ /* eslint-disable no-continue */ import { getArgumentValues, getNamedType, isObjectType, Kind } from 'graphql';
import { setLoaderMappings } from './loader-map.js';
import { createState, mergeSelection, selectionCompatible, selectionToQuery } from './selections.js';
function addTypeSelectionsForField(type, context, info, state, selection, indirectPath) {
    if (selection.name.value.startsWith("__")) {
        return;
    }
    var _extensions;
    const { pothosPrismaInclude, pothosPrismaSelect, pothosPrismaIndirectInclude, pothosPrismaModel } = (_extensions = type.extensions) !== null && _extensions !== void 0 ? _extensions : {};
    if (pothosPrismaIndirectInclude) {
        resolveIndirectInclude(type, info, selection, pothosPrismaIndirectInclude.path, indirectPath, (resolvedType, field, path) => {
            addTypeSelectionsForField(resolvedType, context, info, state, field, path);
        });
    }
    if (!isObjectType(type)) {
        return;
    }
    if (pothosPrismaModel && !pothosPrismaSelect) {
        state.mode = "include";
    }
    if (pothosPrismaInclude || pothosPrismaSelect) {
        mergeSelection(state, {
            select: pothosPrismaSelect ? {
                ...pothosPrismaSelect
            } : undefined,
            include: pothosPrismaInclude ? {
                ...pothosPrismaInclude
            } : undefined
        });
    }
    if (selection.selectionSet) {
        addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
    }
}
function resolveIndirectInclude(type, info, selection, includePath, path, resolve) {
    const [include, ...rest] = includePath;
    if (!selection.selectionSet || !include) {
        return;
    }
    for (const sel of selection.selectionSet.selections) {
        switch (sel.kind) {
            case Kind.FIELD:
                if (sel.name.value === include.name && isObjectType(type)) {
                    const returnType = getNamedType(type.getFields()[sel.name.value].type);
                    if (rest.length === 0) {
                        var ref;
                        var ref1;
                        resolve(returnType, sel, [
                            ...path,
                            (ref1 = (ref = sel.alias) === null || ref === void 0 ? void 0 : ref.value) !== null && ref1 !== void 0 ? ref1 : sel.name.value
                        ]);
                    }
                    else {
                        var ref2;
                        var ref3;
                        resolveIndirectInclude(returnType, info, sel, rest, [
                            ...path,
                            (ref3 = (ref2 = sel.alias) === null || ref2 === void 0 ? void 0 : ref2.value) !== null && ref3 !== void 0 ? ref3 : sel.name.value
                        ], resolve);
                    }
                }
                continue;
            case Kind.FRAGMENT_SPREAD:
                if (info.fragments[sel.name.value].typeCondition.name.value === include.type) {
                    resolveIndirectInclude(info.schema.getType(include.type), info, info.fragments[sel.name.value], includePath, path, resolve);
                }
                continue;
            case Kind.INLINE_FRAGMENT:
                if (!sel.typeCondition || sel.typeCondition.name.value === include.type) {
                    resolveIndirectInclude(sel.typeCondition ? info.schema.getType(sel.typeCondition.name.value) : type, info, sel, includePath, path, resolve);
                }
                continue;
            default:
                throw new Error(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addNestedSelections(type, context, info, state, selections, indirectPath) {
    for (const selection of selections.selections) {
        switch (selection.kind) {
            case Kind.FIELD:
                addFieldSelection(type, context, info, state, selection, indirectPath);
                continue;
            case Kind.FRAGMENT_SPREAD:
                if (info.fragments[selection.name.value].typeCondition.name.value !== type.name) {
                    continue;
                }
                addNestedSelections(type, context, info, state, info.fragments[selection.name.value].selectionSet, indirectPath);
                continue;
            case Kind.INLINE_FRAGMENT:
                if (selection.typeCondition && selection.typeCondition.name.value !== type.name) {
                    continue;
                }
                addNestedSelections(type, context, info, state, selection.selectionSet, indirectPath);
                continue;
            default:
                throw new Error(`Unsupported selection kind ${selection.kind}`);
        }
    }
}
function addFieldSelection(type, context, info, state, selection, indirectPath) {
    var ref;
    if (selection.name.value.startsWith("__")) {
        return;
    }
    const field = type.getFields()[selection.name.value];
    if (!field) {
        throw new Error(`Unknown field ${selection.name.value} on ${type.name}`);
    }
    const fieldSelect = (ref = field.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaSelect;
    let fieldSelectionMap;
    let mappings = {};
    if (typeof fieldSelect === "function") {
        const args = getArgumentValues(field, selection, info.variableValues);
        fieldSelectionMap = fieldSelect(args, context, (rawQuery, indirectInclude) => {
            const returnType = getNamedType(field.type);
            const query = typeof rawQuery === "function" ? rawQuery(args, context) : rawQuery;
            const normalizedIndirectInclude = Array.isArray(indirectInclude) ? normalizeInclude(indirectInclude, getIndirectType(returnType, info)) : indirectInclude;
            const fieldState = createStateForType(getIndirectType(normalizedIndirectInclude ? info.schema.getType(normalizedIndirectInclude.getType()) : returnType, info), info, state);
            if (typeof query === "object" && Object.keys(query).length > 0) {
                mergeSelection(fieldState, {
                    select: {},
                    ...query
                });
            }
            if (normalizedIndirectInclude && normalizedIndirectInclude.path.length > 0) {
                var ref, ref1;
                var ref2;
                resolveIndirectInclude(returnType, info, selection, [
                    ...(ref2 = (ref1 = (ref = returnType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaIndirectInclude) === null || ref1 === void 0 ? void 0 : ref1.path) !== null && ref2 !== void 0 ? ref2 : [],
                    ...normalizedIndirectInclude.path
                ], [], (resolvedType, resolvedField, path) => {
                    addTypeSelectionsForField(resolvedType, context, info, fieldState, resolvedField, path);
                });
            }
            addTypeSelectionsForField(returnType, context, info, fieldState, selection, []);
            // eslint-disable-next-line prefer-destructuring
            mappings = fieldState.mappings;
            return selectionToQuery(fieldState);
        }, (path) => {
            const returnType = getNamedType(field.type);
            let node = null;
            resolveIndirectInclude(returnType, info, selection, path.map((name) => ({
                name
            })), [], (_, resolvedField) => {
                node = resolvedField;
            });
            return node;
        });
    }
    else {
        fieldSelectionMap = {
            select: fieldSelect
        };
    }
    if (fieldSelect && selectionCompatible(state, fieldSelectionMap, true)) {
        var ref1;
        mergeSelection(state, fieldSelectionMap);
        var ref2;
        state.mappings[(ref2 = (ref1 = selection.alias) === null || ref1 === void 0 ? void 0 : ref1.value) !== null && ref2 !== void 0 ? ref2 : selection.name.value] = {
            field: selection.name.value,
            type: type.name,
            mappings,
            indirectPath
        };
    }
}
export function queryFromInfo({ context, info, typeName, select, path = [] }) {
    const type = typeName ? info.schema.getTypeMap()[typeName] : getNamedType(info.returnType);
    const state = createStateForType(type, info);
    if (select) {
        mergeSelection(state, {
            select
        });
    }
    if (path.length > 0) {
        resolveIndirectInclude(getNamedType(info.returnType), info, info.fieldNodes[0], path.map((n) => typeof n === "string" ? {
            name: n
        } : n), [], (resolvedType, resolvedField, nested) => {
            addTypeSelectionsForField(resolvedType, context, info, state, resolvedField, nested);
        });
    }
    else {
        addTypeSelectionsForField(type, context, info, state, info.fieldNodes[0], []);
    }
    setLoaderMappings(context, info, state.mappings);
    return selectionToQuery(state);
}
export function selectionStateFromInfo(context, info, typeName) {
    const type = typeName ? info.schema.getTypeMap()[typeName] : info.parentType;
    const state = createStateForType(type, info);
    if (!isObjectType(type)) {
        throw new Error("Prisma plugin can only resolve includes for object types");
    }
    addFieldSelection(type, context, info, state, info.fieldNodes[0], []);
    return state;
}
function createStateForType(type, info, parent) {
    var ref, ref1;
    const targetType = getIndirectType(type, info);
    const fieldMap = (ref = targetType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaFieldMap;
    return createState(fieldMap, ((ref1 = targetType.extensions) === null || ref1 === void 0 ? void 0 : ref1.pothosPrismaSelect) ? "select" : "include", parent);
}
export function getIndirectType(type, info) {
    var ref;
    let targetType = type;
    while ((ref = targetType.extensions) === null || ref === void 0 ? void 0 : ref.pothosPrismaIndirectInclude) {
        var ref1;
        targetType = info.schema.getType(((ref1 = targetType.extensions) === null || ref1 === void 0 ? void 0 : ref1.pothosPrismaIndirectInclude).getType());
    }
    return targetType;
}
function normalizeInclude(path, type) {
    let currentType = type;
    const normalized = [];
    if (!isObjectType(currentType)) {
        throw new Error(`Expected ${currentType} to be an Object type`);
    }
    for (const fieldName of path) {
        const field = currentType.getFields()[fieldName];
        if (!field) {
            throw new Error(`Expected ${currentType} to have a field ${fieldName}`);
        }
        currentType = getNamedType(field.type);
        if (!isObjectType(currentType)) {
            throw new Error(`Expected ${currentType} to be an Object type`);
        }
        normalized.push({
            name: fieldName,
            type: currentType.name
        });
    }
    return {
        getType: () => normalized.length > 0 ? normalized[normalized.length - 1].type : type.name,
        path: normalized
    };
}
//# sourceMappingURL=map-query.js.map
